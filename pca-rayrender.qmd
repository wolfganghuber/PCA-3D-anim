---
title: "Animation for teaching PCA"
author: "Wolfgang Huber"
date: "`r date()`"
format:
  html:
    embed-resources: false
    page-layout: full
    toc: true
    css: wh.css
highlight-style: tango
---

<!-- {{< video pca-animation.mp4 >}} -->

[Code on GitHub](https://github.com/wolfganghuber/PCA-3D-anim)

**To do / What should be done**:
3D raytracing scene with data as cloud of (metallic) points, together with their original coordinate system. Light source at infinity, 2D plane 'on the floor', showing the shadows of the points. Varianceometers (e.g., barplots) that shows variance components for 1st and 2nd axis of the plane, and residual variance. Point cloud rotating until variances along 1st and 2nd axis are optimized.

```{r}
#| label: loadpkgs
#| message: false
#| warning: false
library("rayrender")
library("animation")
library("RSpincalc")
library("assertthat")
library("dplyr")
```

For more on the decathlon data, see [the MSMB book](https://www.huber.embl.de/msmb/07-chap.html#what-are-the-data-matrices-and-their-motivation).

```{r}
#| label: decathlon
data("olympic", package = "ade4")
athletes = setNames(olympic$tab, c("m100", "long", "weight", "high", "m400", "m110", "disc", "pole", "javel", "m1500"))
variables = c("m100", "weight", "m400")
mat = as.matrix(athletes[, variables])
```

```{r}
#| label: dopca
#| results: "hide"
smat = scale(mat, center = TRUE, scale = TRUE)
pca = prcomp(smat, scale. = FALSE, center = FALSE)
```
Make sure the rotation has positive determinant and extract Euler angles representation.
```{r}
#| label: Eulerangles
#| results: "hide"
assert_that(are_equal(smat %*% pca$rotation, pca$x, check.attributes = FALSE))
if(det(pca$rotation) < 0) {
  pca$rotation[,3] = -pca$rotation[,3] 
  pca$x[,3] = -pca$x[,3]
  assert_that(are_equal(smat %*% pca$rotation, pca$x, check.attributes = FALSE))
}
angles = DCM2EA(pca$rotation)
assert_that(are_equal(EA2DCM(angles), pca$rotation, check.attributes = FALSE))
```


1. Implement rotation, but for only 3 points show the spheres to save time
2. Add variance barplots in separate PNG
3. Combine using imagemagick
4. Loop and maximize first PC1, then PC2

```{r}
#| fig-width: 5
#| fig-height: 5
#| out-width: "100%"
#| label: scene
devsize = c(width = 400, height1 = 400, height2 = 200)
var_ax_orig  = c(-3, -3, +3)
var_axes = diag(x = 1, nrow = 3) * 2
var_axes[, 3] = -var_axes[, 3]

pc_ax_orig  = c(-4, -10, +4)
pc_axes  = rbind(c( 1,  0),
                 c( 0,  0),
                 c( 0, -1)) * 1.5
pointcol = "#2b6eff"

frames = tibble(EA = angles)

for (f in seq_len(nrow(frames))) {
  rot = EA2DCM(frames$EA[f,])
  pts = smat %*% rot
  
  scene = generate_ground(
    material = diffuse(color = "#cccccc", fogdensity = 0, sigma = 0), depth = -10)

  for(i in seq_len(nrow(pts))) 
    scene = add_object(scene, 
      sphere(x = pts[i, 1], y = pts[i, 2], z = pts[i, 3], radius = 0.15,
             material = glossy(color = pointcol, reflectance = 0.05)))
  
  for(i in 1:3) 
    scene = add_object(scene, 
      arrow(start = var_ax_orig, 
            end   = var_ax_orig + var_axes[, i], 
            tail_proportion = 0.9, radius_top = 0.1, radius_tail = 0.05,
            material = diffuse(color = pointcol))) 
  
  for(i in 1:2)
    scene = add_object(scene, 
      arrow(start = pc_ax_orig, 
            end =   pc_ax_orig + pc_axes[, i], 
            tail_proportion = 0.9, radius_top = 0.1, radius_tail = 0.05,
            material = diffuse(color = "black")))
  
  # large distance and very bright to emulate parallel light. Is there a more elegant light source?
  scene = add_object(scene, sphere(y = 1000, material = light(intensity = 500000)))

  render_scene(scene, parallel = TRUE, 
               width = devsize["width"], height = devsize["height1"], samples = 128,
               lookfrom = c(0, 50, 10), lookat = c(0, 0, 0), clamp_value = 8,
               filename = sprintf("frames/scene_%03d.png", f))
  
  png(file = sprintf("frames/plot_%03d.png", f), width = devsize["width"], height = devsize["height2"])
    plot(1:10)
  dev.off()
} # for f
```

# Session Info

```{r}
#| label: sessioninfo
Sys.time()
devtools::session_info()
```



```{r}
#| label: animate
#| eval: false
# Set up the folder to save frames
dir.create("frames")

# Number of frames
num_frames <- 60

# Render each frame with a slightly different angle
for (i in seq_len(num_frames)) {
  # Calculate the position of the sphere in each frame (for example, rotating around the y-axis)
  angle <- i * (2 * pi / num_frames)
  x_pos <- 3 * cos(angle)
  z_pos <- 3 * sin(angle)
  
  # Update the scene with the new position of the sphere
  animated_scene <- add_object(base_scene, sphere(x = x_pos, y = 1, z = z_pos, radius = 1, material = diffuse(color = "blue")))
  
  # Render the scene and save the frame as an image
  render_scene(animated_scene, samples = 100, width = 800, height = 800, 
               filename = sprintf("frames/frame_%03d.png", i))
}
```
```{sh}
#| label: ffmpeg
#| eval: false
ffmpeg -framerate 30 -i frames/frame_%03d.png -c:v libx264 -pix_fmt yuv420p animation.mp4
```